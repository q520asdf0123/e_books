package com.tiny.hero.plat.module.account;

import cn.hutool.core.util.CharsetUtil;
import cn.hutool.http.HttpUtil;
import com.alibaba.fastjson.JSON;
import com.alibaba.fastjson.JSONObject;
import com.google.common.collect.Lists;
import com.google.common.collect.Maps;
import com.tiny.hero.plat.common.constant.AuditType;
import com.tiny.hero.plat.common.constant.GameError;
import com.tiny.hero.plat.common.constant.HttpGameError;
import com.tiny.hero.plat.common.domain.ResponseDTO;
import com.tiny.hero.plat.config.KingwarConfig;
import com.tiny.hero.plat.config.PlayerIdSeq;
import com.tiny.hero.plat.constant.BindType;
import com.tiny.hero.plat.constant.ProtoConstant;
import com.tiny.hero.plat.module.account.dao.AccountDao;
import com.tiny.hero.plat.module.account.dao.PayDao;
import com.tiny.hero.plat.module.account.dao.RoleDao;
import com.tiny.hero.plat.module.account.domain.dto.*;
import com.tiny.hero.plat.module.account.domain.entity.AccountEntity;
import com.tiny.hero.plat.module.account.domain.entity.PayInfo;
import com.tiny.hero.plat.module.account.domain.vo.BindVo;
import com.tiny.hero.plat.module.account.domain.vo.LoginVo;
import com.tiny.hero.plat.module.account.domain.vo.VerifyVo;
import com.tiny.hero.plat.module.account.plat.LoginPlatFactory;
import com.tiny.hero.plat.module.account.plat.PlatBase;
import com.tiny.hero.plat.module.channel.ChannelCache;
import com.tiny.hero.plat.module.channel.domain.entity.ChannelEntity;
import com.tiny.hero.plat.module.identityCard.dao.IdentityCardDao;
import com.tiny.hero.plat.module.identityCard.entity.IdentityCard;
import com.tiny.hero.plat.module.server.ServerCache;
import com.tiny.hero.plat.module.server.ServerService;
import com.tiny.hero.plat.module.server.domain.entity.ServerEntity;
import com.tiny.hero.plat.service.IAppleService;
import com.tiny.hero.plat.util.DuokeHttpUtil;
import com.tiny.hero.plat.util.HolidayUtils;
import com.tiny.hero.plat.util.HttpPacket;
import com.tiny.hero.plat.util.RSAUtil;
import lombok.extern.slf4j.Slf4j;
import org.apache.commons.lang3.StringUtils;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.beans.factory.annotation.Value;
import org.springframework.stereotype.Service;
import org.springframework.transaction.annotation.Transactional;

import javax.annotation.PostConstruct;
import javax.annotation.Resource;
import javax.servlet.http.HttpServletRequest;
import java.time.LocalDate;
import java.time.LocalDateTime;
import java.time.ZoneId;
import java.time.format.DateTimeFormatter;
import java.time.temporal.ChronoUnit;
import java.util.*;

@Service
@Slf4j
public class AccountService {

    @Autowired
    private LoginPlatFactory loginPlatFactory;
    @Autowired
    private AccountDao accountDao;
    @Autowired
    private ChannelCache channelCache;
    @Autowired
    private TokenManager tokenManager;
    @Autowired
    private ServerCache serverCache;
    @Autowired
    private IAppleService iAppleService;
    @Autowired
    private ServerService serverService;

    @Autowired
    private PlayerIdSeq playerIdSeq;
    @Autowired
    private KingwarConfig kingwarConfig;

    @Resource
    private IdentityCardDao identityCardDao;
    @Resource
    private PayDao payDao;
    @Resource
    private RoleDao roleDao;

    @Value("${open.auto}")
    private boolean openAuto;

    private final Map<String, List<AccountEntity>> map = Maps.newHashMap();

    @PostConstruct
    private void init() {
        List<AccountEntity> list = accountDao.getCount();
        for (AccountEntity accountEntity : list) {
            String uuid = accountEntity.getUuid();
            if (!map.containsKey(uuid)) {
                map.put(uuid, Lists.newArrayList());
            }
            map.get(uuid).add(accountEntity);
        }
    }

    public ResponseDTO<LoginVo> login(LoginDto req) {
        String channelId = req.getChannelId();
        ChannelEntity channelEntity = channelCache.getChannel(channelId);
        if (channelEntity == null) {
            return ResponseDTO.wrap(GameError.ERROR_PARAM, "渠道不存在");
        }
        req.setLoginPlat(channelEntity.getLoginPlat());

        PlatBase platImpl = loginPlatFactory.getPlatImpl(channelEntity.getLoginPlat());
        if (platImpl == null) {
            return ResponseDTO.wrap(GameError.ERROR_PARAM, "错误的登录方式");
        }
        Integer bindType = BindType.getByType(req.getLoginFlag());
        if (Objects.nonNull(bindType)) {
            String uuid = req.getUuid();
            if (StringUtils.isBlank(uuid)) {
                try {
                    String playerId = playerIdSeq.getPlayerId();
                    String clientId = HttpUtil.get(kingwarConfig.getDuokeplatGetClientUrl(), CharsetUtil.CHARSET_UTF_8);
                    Map<String, String> map = Maps.newHashMap();
                    map.put("clientId", clientId);
                    map.put("playerId", playerId);
                    req.setUuid(RSAUtil.encryptByPublicKey(JSON.toJSONString(map)));
                } catch (Exception e) {
                    log.error("获取UUID失败");
                    e.printStackTrace();
                    return ResponseDTO.wrap(GameError.PLAT_LOGIN_FAILD, "获取UUID失败");
                }
            }
        } else {
            bindType = BindType.tinynet.getId();
        }

        PlatResultDto resultDto = platImpl.doLogin(req);
        if (!resultDto.isSucc()) {
            log.error("登录失败req:{} data:{}", req, resultDto);
            return ResponseDTO.wrap(GameError.PLAT_LOGIN_FAILD, resultDto.getMsg());
        }

        if (StringUtils.isBlank(resultDto.getLoginChannel())) {
            log.error("错误：{}", resultDto);
            throw new NullPointerException();
        }

        log.warn("登录参数:{}", JSON.toJSONString(req));

        String clientId = resultDto.getAccount();
        long now = System.currentTimeMillis();
        if (StringUtils.isNotBlank(req.getUuid())) {
            String encryptByPublicKey = null;
            try {
                encryptByPublicKey = RSAUtil.decryptByPrivateKey(req.getUuid());
            } catch (Exception e) {
                e.printStackTrace();
            }
            JSONObject json = JSONObject.parseObject(encryptByPublicKey);
            clientId = json.getString("clientId");
        }

        String account = resultDto.getAccount();
        AccountEntity accountEntity = accountDao.getByAccountAndLoginChannel(account, resultDto.getLoginChannel());
        if (accountEntity == null) {
            accountEntity = AccountEntity.builder().deviceId(req.getDeviceId()).channelId(channelId).account(account)
                    .loginChannel(resultDto.getLoginChannel()).createTime(new Date(now)).createIp(req.getIp())
                    .lastLoginIp(req.getIp()).lastLoginTime(new Date(now)).audit(AuditType.NONE.getType())
                    .deviceModel(req.getDeviceModel()).deviceName(req.getDeviceName()).lastDeviceModel(req.getDeviceModel())
                    .lastDeviceName(req.getDeviceName()).serverIds(new ArrayDeque<>()).bindAccount(account)
                    .version(req.getVersion()).pkgVersion(req.getPkgVersion()).lastVersion(req.getVersion())
                    .lastPkgVersion(req.getPkgVersion()).initDeviceType(req.getDeviceType()).deviceType(req.getDeviceType())
                    .bindType(bindType + "").uuid(clientId).build();
            accountDao.insertAccount(accountEntity);
        } else if (accountEntity.getStatus() == 1) {
            // 先把原来的数据存起来并删除
            accountDao.insertDeleteAccount(accountEntity);
            accountDao.deleteById(accountEntity.getId());

            // 生成新的数据
            accountEntity = AccountEntity.builder().deviceId(req.getDeviceId()).channelId(channelId)
                    .account(playerIdSeq.getPlayerId()).loginChannel(resultDto.getLoginChannel()).createTime(new Date(now))
                    .createIp(req.getIp()).lastLoginIp(req.getIp()).lastLoginTime(new Date(now))
                    .audit(accountEntity.getAudit()).serverIds(new ArrayDeque<>()).bindAccount(account)
                    .bindType(bindType + "").uuid(clientId).deviceModel(req.getDeviceModel())
                    .deviceName(req.getDeviceName()).lastDeviceModel(req.getDeviceModel())
                    .lastDeviceName(req.getDeviceName()).version(req.getVersion()).pkgVersion(req.getPkgVersion())
                    .initDeviceType(req.getDeviceType()).deviceType(req.getDeviceType()).lastVersion(req.getVersion())
                    .lastPkgVersion(req.getPkgVersion()).bindType(bindType + "").build();
            accountDao.insertAccount(accountEntity);
        } else {
            accountEntity.setLastLoginTime(new Date(now));
            accountEntity.setLastLoginIp(req.getIp());
            accountEntity.setServerIds(getLastLogServers(accountEntity.getId()));
            accountEntity.setUuid(clientId);
            accountEntity.setLastDeviceModel(accountEntity.getDeviceModel());
            accountEntity.setLastDeviceName(accountEntity.getDeviceName());
            accountEntity.setDeviceModel(req.getDeviceModel());
            accountEntity.setDeviceName(req.getDeviceName());
            accountEntity.setLastVersion(accountEntity.getVersion());
            accountEntity.setLastPkgVersion(accountEntity.getPkgVersion());
            accountEntity.setVersion(req.getVersion());
            accountEntity.setPkgVersion(req.getPkgVersion());
            accountEntity.setDeviceType(req.getDeviceType());
            if (StringUtils.isBlank(accountEntity.getInitDeviceType())) {
                accountEntity.setInitDeviceType(req.getDeviceType());
            }
            accountDao.updateByLogin(accountEntity);
        }

        accountEntity.setUuid(req.getUuid());
        accountEntity.setAccount(accountEntity.getBindAccount());
        if (accountEntity.getForbid() == 1) {
            return ResponseDTO.wrap(GameError.FORBID);
        }

        String token = tokenManager.createToken(accountEntity.getId(), channelId, accountEntity.getBindAccount(), now,
                req.getDeviceId());

        LoginVo data = LoginVo.valueOf(accountEntity, platImpl.getLoginPlat(), token, now, req.getUuid(),
                isGuest(req.getLoginFlag()));

        if (openAuto) {
            if (accountEntity.getAudit() == AuditType.NO_ADULT.getType()) {
                IdentityCard identityCard = identityCardDao.queryId(accountEntity.getId());
                String birthday = JSONObject.parseObject(identityCard.getIdCardInfor()).getJSONObject("IdCardInfor")
                        .getString("birthday");
                String[] split = birthday.split("-");
                LocalDate localDate =
                        LocalDate.of(Integer.parseInt(split[0]), Integer.parseInt(split[1]), Integer.parseInt(split[2]));
                LocalDate curr = LocalDate.now();
                long year = ChronoUnit.YEARS.between(localDate, curr);
                if (year >= 18) {
                    accountEntity.setAudit(AuditType.ADULT.getType());
                    accountDao.updateByAudit(accountEntity);
                } else {
                    int curMinute = HolidayUtils.surplusMinute();
                    if (!HolidayUtils.isWorkingDay() || curMinute <= 0) {
                        return ResponseDTO.wrap(GameError.LOGIN_PROHIBITED);
                    }

                    data.setCurMinute(curMinute);
                }

                data.setCurYear((int) year);
                if (year < 8) {
                    data.setMaxRechargeAmount(0);
                    data.setMaxSingleRechargeAmount(0);
                } else if (year < 16) {
                    data.setMaxSingleRechargeAmount(5000);
                    data.setMaxRechargeAmount(20000);
                } else if (year < 18) {
                    data.setMaxSingleRechargeAmount(10000);
                    data.setMaxRechargeAmount(40000);
                } else {
                    data.setMaxSingleRechargeAmount(99999999);
                    data.setMaxRechargeAmount(99999999);
                }

                List<Long> roleIds = roleDao.selectRoleIdsByUserId(accountEntity.getId());
                Integer total = 0;
                if (!roleIds.isEmpty()) {
                    // 获取本月第一天和最后一天，格式化为字符串
                    LocalDateTime startOfMonth = LocalDateTime.now().withDayOfMonth(1).withHour(0).withMinute(0).withSecond(0).withNano(0);
                    LocalDateTime endOfMonth = startOfMonth.plusMonths(1).minusSeconds(1);
                    DateTimeFormatter formatter = DateTimeFormatter.ofPattern("yyyy-MM-dd HH:mm:ss");
                    String startTime = startOfMonth.format(formatter);
                    String endTime = endOfMonth.format(formatter);

                    total = payDao.getTotalAmountByRoleIds(roleIds, startTime, endTime);
                }
                data.setTotalRechargeAmount(total);

                log.warn("版号参数:{}", JSON.toJSONString(data));
            }
        }


        data.setAudit(accountEntity.getAudit());

//        data.setCurYear(17);
//        data.setMaxSingleRechargeAmount(10);
//        data.setMaxRechargeAmount(10);
//        data.setTotalRechargeAmount(100);
//        data.setAudit(AuditType.NO_ADULT.getType());

        return ResponseDTO.succData(data);
    }

    public ResponseDTO<VerifyVo> verify(VerifyDto req) {
        String token = tokenManager.getAccountToken(req.getAccountKey());
        if (token == null || "null".equals(token)) {
            return ResponseDTO.wrap(GameError.TOKEN_FAILD);
        }
        if (!token.equals(req.getToken())) {
            return ResponseDTO.wrap(GameError.TOKEN_FAILD);
        }

        AccountEntity accountEntity = accountDao.getById(req.getAccountKey());
        if (accountEntity == null) {
            return ResponseDTO.wrap(GameError.NO_USER);
        }
        if (accountEntity.getForbid() == 1) {
            return ResponseDTO.wrap(GameError.FORBID);
        }

        return ResponseDTO.succData(VerifyVo.valueOf(accountEntity));
    }

    public String payBack(HttpServletRequest request, String plat) {
        PlatBase platImpl = loginPlatFactory.getPlatImpl(plat);
        return platImpl.payBack(request);
    }

    public String buDan(PayInfo payInfo) {
        ChannelEntity channelEntity = channelCache.getChannel(payInfo.getChannelId());
        if (channelEntity == null) {
            return "渠道不存在";
        }

        PlatBase platImpl = loginPlatFactory.getPlatImpl(channelEntity.getLoginPlat());
        return "" + platImpl.buDan(payInfo);
    }

    public String gmTools(JSONObject data) {
        HttpGameError gameError = HttpGameError.DEFAULT;
        String serverId = (String) data.get("serverId");
        String url = serverCache.getServer(Integer.parseInt(serverId)).getHttpAddress();
        if (url == null) {// 无法取到游戏服地址
            gameError = HttpGameError.SERVER_NO_EXIST;
            return JSON.toJSONString(new HttpPacket(ProtoConstant.GetInfoRq, gameError.getCode()));
        }

        HttpPacket body = new HttpPacket(ProtoConstant.GetInfoRq, HttpGameError.DEFAULT.getCode(), data);
        return DuokeHttpUtil.sentPost(url, JSON.toJSONString(body));
    }

    public ArrayDeque<Integer> getLastLogServers(int id) {
        ArrayDeque<Integer> queue = new ArrayDeque<>(3);
        String serverIds = accountDao.getLastLoginByAccId(id);
        if (serverIds == null || serverIds.isEmpty()) {
            return queue;
        }
        String[] ss = serverIds.split(",");
        for (String serverId : ss) {
            queue.add(Integer.parseInt(serverId.trim()));
        }
        return queue;
    }

    @Transactional(rollbackFor = Exception.class)
    public ResponseDTO<BindVo> bind(BindDto req) {
        String uuid = req.getUuid();
        String identityToken = req.getIdentityToken();
        String bindAccount = req.getBindAccount();
        String bindType = req.getBindType();
        String channelId = req.getChannelId();
        int serverId = req.getServerId();

        ServerEntity server = serverCache.getServer(serverId);
        if (Objects.isNull(server) || StringUtils.isBlank(server.getHttpAddress())) {
            return ResponseDTO.wrap(GameError.BIND_ERROR, "服务信息错误");
        }

        String httpAddress = server.getHttpAddress();

        Integer type = BindType.getByType(bindType);
        if (type == null) {
            log.error(uuid + "找不到bindType");
            return ResponseDTO.wrap(GameError.BIND_ERROR, "找不到bindType");
        }
        ChannelEntity channelEntity = channelCache.getChannel(channelId);
        if (channelEntity == null) {
            log.error(uuid + "渠道不存在");
            return ResponseDTO.wrap(GameError.BIND_ERROR, "渠道不存在");
        }
        req.setLoginPlat(channelEntity.getLoginPlat());

        String clientId;
        try {
            clientId = JSONObject.parseObject(RSAUtil.decryptByPrivateKey(uuid)).getString("clientId");
        } catch (Exception e) {
            log.error("非法的uuid");
            e.printStackTrace();
            return ResponseDTO.wrap(GameError.BIND_ERROR, "非法的uuid");
        }

        PlatBase platImpl = loginPlatFactory.getPlatImpl(channelEntity.getLoginPlat());
        if (platImpl == null) {
            log.error(uuid + "错误的登录方式");
            return ResponseDTO.wrap(GameError.BIND_ERROR, "错误的登录方式");
        }
        AccountEntity accountEntity = accountDao.getByClient(clientId, req.getLoginPlat());
        if (Objects.isNull(accountEntity)) {
            log.error(uuid + "账号不存在");
            return ResponseDTO.wrap(GameError.BIND_ERROR, "账号不存在");
        }

        AccountEntity entity = accountDao.getByAccountAndLoginChannel(bindAccount, req.getLoginPlat());
        switch (bindType) {
            case "apple": {
                Map<String, Object> appleUserInfo = Maps.newHashMap();
                try {
                    appleUserInfo = iAppleService.getAppleUserInfo(identityToken);
                } catch (Exception ignored) {
                }
                if (!appleUserInfo.isEmpty()) {
                    Object data = appleUserInfo.get("data");
                    if (data == null) {
                        return ResponseDTO.wrap(GameError.BIND_ERROR, "绑定失败，请重试");
                    }
                    JSONObject resultJson = (JSONObject) JSONObject.toJSON(data);
                    String sub = resultJson.getString("sub");
                    if (!sub.equals(bindAccount)) {
                        log.error("绑定账号不匹配");
                        return ResponseDTO.wrap(GameError.BIND_ERROR, "绑定账号不匹配");
                    }
                } else {
                    log.error("json格式错误");
                    return ResponseDTO.wrap(GameError.BIND_ERROR, "json格式错误");
                }
            }
            break;
            case "facebook": {
                Map<String, Object> appleUserInfo = Maps.newHashMap();
                try {
                    appleUserInfo = iAppleService.getUserInfo(identityToken);
                } catch (Exception ignored) {
                }
                if (!appleUserInfo.isEmpty()) {
                    Object data = appleUserInfo.get("data");
                    if (data == null) {
                        return ResponseDTO.wrap(GameError.BIND_ERROR, "绑定失败，请重试");
                    }
                    JSONObject resultJson = (JSONObject) JSONObject.toJSON(data);
                    String aud = resultJson.getString("user_id");
                    if (!aud.equals(bindAccount)) {
                        log.error("绑定账号不匹配");
                        return ResponseDTO.wrap(GameError.BIND_ERROR, "绑定账号不匹配");
                    }
                } else {
                    log.error("json格式错误");
                    return ResponseDTO.wrap(GameError.BIND_ERROR, "json格式错误");
                }
            }
            break;
            default:
                log.error("找不到绑定的平台");
                return ResponseDTO.wrap(GameError.BIND_ERROR, "找不到绑定的平台");
        }

        if (entity != null && entity.getStatus() == 1) {
            // 先把原来的数据存起来并删除
            accountDao.insertDeleteAccount(entity);
            accountDao.deleteById(entity.getId());
        }

        String sentPost;
        HttpPacket httpPacket;
        if (Objects.isNull(entity)) {
            accountEntity.setBindAccount(bindAccount);
            accountEntity.setBindType(type + "");

            JSONObject jsonObject = new JSONObject();
            jsonObject.put("key", accountEntity.getId());
            jsonObject.put("oldKey", accountEntity.getId());
            httpPacket = new HttpPacket("Bind", jsonObject);
        } else {
            JSONObject jsonObject = new JSONObject();
            jsonObject.put("key", entity.getId());
            jsonObject.put("oldKey", accountEntity.getId());
            httpPacket = new HttpPacket("Bind", jsonObject);
        }

        sentPost = DuokeHttpUtil.sentPost(httpAddress, JSON.toJSONString(httpPacket));
        if (StringUtils.isBlank(sentPost)) {
            throw new RuntimeException("绑定失败" + sentPost);
        }

        JSONObject j = JSONObject.parseObject(sentPost);
        int code = j.getIntValue("code");
        if (code != 10000) {
            // if (code == 201) {
            // return ResponseDTO.wrap(GameError.BIND_ERROR, "绑定信息错误");
            // }
            //
            // if (code == 203) {
            // return ResponseDTO.wrap(GameError.USER_EXIST, "账号已绑定");
            // }

            throw new RuntimeException("绑定失败" + sentPost);
        }

        if (Objects.isNull(entity)) {
            accountDao.bindAccount(accountEntity);
        }

        tokenManager.updateAppleToken(bindAccount, identityToken);

        return ResponseDTO.succData(BindVo.valueOf(accountEntity, identityToken, 1));
    }

    public ResponseDTO<LoginVo> codeLogin(LoginDto req) {
        String channel = req.getChannelId();
        String version = req.getVersion();
        String code = req.getCode();
        if (!serverService.isProcess(channel, version)) {
            return ResponseDTO.wrap(GameError.ERROR_PARAM);
        }
        if (StringUtils.isBlank(code)) {
            return ResponseDTO.wrap(GameError.ERROR_PARAM);
        }
        String token = tokenManager.getToken(code);
        if (StringUtils.isBlank(token)) {
            System.out.println(code + " code不存在");
            return ResponseDTO.wrap(GameError.ERROR_PARAM);
        }
        long now = System.currentTimeMillis();
        JSONObject jsonObject = JSONObject.parseObject(token);
        String account = jsonObject.getString("account");
        String loginPlat = jsonObject.getString("loginPlat");
        String type = jsonObject.getString("type");

        AccountEntity accountEntity = accountDao.getByAccountAndLoginChannel(account, loginPlat);
        if (accountEntity == null) {
            return ResponseDTO.wrap(GameError.NO_USER);
        } else {
            accountEntity.setLastLoginTime(new Date(now));
            accountEntity.setLastLoginIp(req.getIp());
            accountEntity.setAudit(AuditType.NONE.getType());
            accountEntity.setServerIds(getLastLogServers(accountEntity.getId()));
            accountDao.updateByLogin(accountEntity);
        }

        if (accountEntity.getForbid() == 1) {
            return ResponseDTO.wrap(GameError.FORBID);
        }

        String token1 = tokenManager.createToken(accountEntity.getId(), channel, accountEntity.getAccount(), now,
                req.getDeviceId());
        return ResponseDTO.succData(LoginVo.valueOf(accountEntity, loginPlat, token1, now, req.getUuid(), 1));
    }

    private int isGuest(String loginFlag) {
        return "guest".equals(loginFlag) ? 0 : 1;
    }

    public static void main(String[] args) {
        Map<String, String> map = Maps.newHashMap();
        map.put("account", "12456789");
        map.put("channelId", "tinynet");
        map.put("loginPlat", "duoke");
        map.put("type", "0");
        System.out.println(JSON.toJSONString(map));

        LocalDateTime startOfMonth = LocalDateTime.now().withDayOfMonth(1).withHour(0).withMinute(0).withSecond(0).withNano(0);
        LocalDateTime endOfMonth = startOfMonth.plusMonths(1).minusSeconds(1);
        DateTimeFormatter formatter = DateTimeFormatter.ofPattern("yyyy-MM-dd HH:mm:ss");
        String startTime = startOfMonth.format(formatter);
        String endTime = endOfMonth.format(formatter);

        System.out.println(startTime);
        System.out.println(endTime);
    }

    public ResponseDTO delete(DeleteDto req) {
        String channelId = req.getChannelId();
        String userId = req.getUserId();
        ChannelEntity channelEntity = channelCache.getChannel(channelId);
        if (channelEntity == null) {
            return ResponseDTO.wrap(GameError.DELETE_ERROR, "渠道不存在");
        }
        req.setLoginPlat(channelEntity.getLoginPlat());

        PlatBase platImpl = loginPlatFactory.getPlatImpl(channelEntity.getLoginPlat());
        if (platImpl == null) {
            return ResponseDTO.wrap(GameError.DELETE_ERROR, "错误的登录方式");
        }

        AccountEntity accountEntity = accountDao.getByAccountAndLoginChannel(userId, req.getLoginPlat());
        if (accountEntity == null || accountEntity.getStatus() == 1) {
            return ResponseDTO.wrap(GameError.DELETE_ERROR, "用户不存在");
        }

        String uuid = accountEntity.getUuid();
        if (map.containsKey(uuid) && map.get(uuid).size() >= 5) {
            return ResponseDTO.wrap(GameError.DELETE_OVER_COUNT, "删除账号次数超过最大限制");
        }
        accountDao.updateStatus(userId, req.getLoginPlat());
        if (!map.containsKey(uuid)) {
            map.put(uuid, Lists.newArrayList());
        }
        map.get(uuid).add(accountEntity);

        return ResponseDTO.succ();
    }

}
