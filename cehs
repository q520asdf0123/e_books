package com.tiny.hero.plat.module.identityCard;

import javax.crypto.Cipher;
import javax.crypto.spec.IvParameterSpec;
import javax.crypto.spec.SecretKeySpec;
import java.nio.charset.StandardCharsets;
import java.util.Base64;
import java.util.Arrays;

public class DesDecryptor {

    public static void main(String[] args) throws Exception {
        // --- 准备工作：模拟加密过程 ---

        // 1. 必须使用与加密时完全相同的 salt！
        String salt = "@KeuL1FS"; // 这是一个示例 salt，请替换为你自己的
        String originalText = "4rhFSDA9y/nrLb9NMVjUOY/1FNNhlirV"; // 你的 req.getCode()

        // 加密 (为了生成一个可供解密的密文)
        byte[] keyBytes = getKeyOrIv(salt.getBytes(StandardCharsets.UTF_8));
        byte[] ivBytes = getKeyOrIv(salt.getBytes(StandardCharsets.UTF_8));
        
        SecretKeySpec secretKey = new SecretKeySpec(keyBytes, "DES");
        IvParameterSpec iv = new IvParameterSpec(ivBytes);
        Cipher encryptCipher = Cipher.getInstance("DES/CBC/PKCS5Padding");
        encryptCipher.init(Cipher.ENCRYPT_MODE, secretKey, iv);
        
        byte[] encryptedBytes = encryptCipher.doFinal(originalText.getBytes(StandardCharsets.UTF_8));
        String base64EncryptedString = Base64.getEncoder().encodeToString(encryptedBytes);
        
        System.out.println("原始文本: " + originalText);
        System.out.println("加密后的Base64字符串: " + base64EncryptedString);
        System.out.println("------------------------------------------");


        // --- 核心：解密过程 ---
        String decryptedText = decrypt(originalText, salt);

        System.out.println("解密后的文本: " + decryptedText);

        // 验证解密是否成功
        if (originalText.equals(decryptedText)) {
            System.out.println("成功: 解密后的文本与原始文本一致！");
        } else {
            System.out.println("失败: 解密结果不正确！");
        }
    }

    /**
     * 使用DES/CBC/PKCS5Padding进行解密
     *
     * @param base64EncryptedString Base64编码的加密字符串
     * @param salt                  用于生成密钥和IV的盐值（必须与加密时相同）
     * @return 解密后的原始字符串
     * @throws Exception 如果解密失败
     */
    public static String decrypt(String base64EncryptedString, String salt) throws Exception {
        // 1. 将Base64编码的密文解码成字节数组
        byte[] encryptedBytes = Base64.getDecoder().decode(base64EncryptedString);

        // 2. 使用与加密时完全相同的 salt 和编码（如UTF-8）生成密钥和IV
        //    注意：DES的密钥和IV长度必须是8字节！
        byte[] keyBytes = getKeyOrIv(salt.getBytes(StandardCharsets.UTF_8));
        byte[] ivBytes = getKeyOrIv(salt.getBytes(StandardCharsets.UTF_8));
        
        SecretKeySpec secretKey = new SecretKeySpec(keyBytes, "DES");
        IvParameterSpec iv = new IvParameterSpec(ivBytes);

        // 3. 创建Cipher实例
        Cipher decryptCipher = Cipher.getInstance("DES/CBC/PKCS5Padding");

        // 4. 初始化Cipher为解密模式
        decryptCipher.init(Cipher.DECRYPT_MODE, secretKey, iv);

        // 5. 执行解密
        byte[] decryptedBytes = decryptCipher.doFinal(encryptedBytes);

        // 6. 将解密后的字节数组转换为字符串（使用正确的编码）
        return new String(decryptedBytes, StandardCharsets.UTF_8);
    }
    
    /**
     * DES算法要求密钥和IV的长度必须是8字节（64位）。
     * 如果提供的字节数组长度不是8，需要进行处理。
     * 常见的处理方式是取前8个字节。
     *
     * @param originalBytes 原始字节数组
     * @return 8字节的数组
     */
    private static byte[] getKeyOrIv(byte[] originalBytes) {
        byte[] result = new byte[8];
        // 如果原始字节数不足8，则用0填充；如果超过8，则截取前8位。
        // Arrays.copyOf 完美地实现了这个逻辑。
        System.arraycopy(originalBytes, 0, result, 0, Math.min(originalBytes.length, 8));
        return result;
    }
}
